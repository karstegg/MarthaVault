/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MarthaAgentPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var MarthaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Martha Agent Settings" });
    containerEl.createEl("p", {
      text: "This plugin embeds Claude CLI directly inside Obsidian. Make sure Claude Code is installed globally.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Terminal position").setDesc("Where to open the Claude terminal panel").addDropdown((dropdown) => dropdown.addOption("right", "Right sidebar").addOption("bottom", "Bottom panel").setValue(this.plugin.settings.terminalPosition).onChange(async (value) => {
      this.plugin.settings.terminalPosition = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Font size").setDesc("Terminal font size (requires reopening terminal)").addSlider((slider) => slider.setLimits(10, 20, 1).setValue(this.plugin.settings.fontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.fontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-start Claude").setDesc('Automatically run "claude" command when opening terminal').addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartClaude).onChange(async (value) => {
      this.plugin.settings.autoStartClaude = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Setup Instructions" });
    const instructions = containerEl.createEl("div", { cls: "martha-setup-instructions" });
    instructions.createEl("p", { text: "1. Install Claude Code globally:" });
    instructions.createEl("pre", { text: "npm install -g @anthropic-ai/claude-code" });
    instructions.createEl("p", { text: "2. Set up authentication:" });
    instructions.createEl("pre", { text: "claude setup-token" });
    instructions.createEl("p", { text: "3. Open terminal in Obsidian:" });
    instructions.createEl("p", { text: 'Use the ribbon icon (terminal) or Command Palette \u2192 "Open Claude Terminal"' });
    instructions.createEl("p", { text: "4. The terminal will start in your vault directory with full Claude Code features." });
    const style = containerEl.createEl("style");
    style.textContent = `
      .martha-setup-instructions {
        background: var(--background-secondary);
        padding: 16px;
        border-radius: 8px;
        margin-top: 12px;
      }

      .martha-setup-instructions p {
        margin: 8px 0;
      }

      .martha-setup-instructions pre {
        background: var(--background-primary);
        padding: 8px 12px;
        border-radius: 4px;
        font-family: 'Consolas', 'Courier New', monospace;
        font-size: 13px;
        color: var(--text-accent);
        margin: 4px 0 12px 0;
      }
    `;
  }
};

// terminal.ts
var import_obsidian2 = require("obsidian");
var import_xterm = require("xterm");
var import_xterm_addon_fit = require("xterm-addon-fit");
var import_xterm_addon_web_links = require("xterm-addon-web-links");
var pty = __toESM(require("node-pty"));
var os = __toESM(require("os"));
var path = __toESM(require("path"));
var TERMINAL_VIEW_TYPE = "martha-terminal";
var TerminalView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.ptyProcess = null;
    this.resizeObserver = null;
    this.plugin = plugin;
    this.vaultPath = this.app.vault.adapter.basePath;
  }
  getViewType() {
    return TERMINAL_VIEW_TYPE;
  }
  getDisplayText() {
    return "Claude Terminal";
  }
  getIcon() {
    return "terminal";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("martha-terminal-container");
    const terminalDiv = container.createDiv({ cls: "xterm-container" });
    this.terminal = new import_xterm.Terminal({
      cursorBlink: true,
      fontSize: 14,
      fontFamily: 'Consolas, "Courier New", monospace',
      theme: {
        background: "var(--background-primary)",
        foreground: "var(--text-normal)",
        cursor: "var(--text-accent)",
        cursorAccent: "var(--background-primary)",
        selectionBackground: "var(--text-selection)",
        black: "#000000",
        red: "#e06c75",
        green: "#98c379",
        yellow: "#d19a66",
        blue: "#61afef",
        magenta: "#c678dd",
        cyan: "#56b6c2",
        white: "#abb2bf",
        brightBlack: "#5c6370",
        brightRed: "#e06c75",
        brightGreen: "#98c379",
        brightYellow: "#d19a66",
        brightBlue: "#61afef",
        brightMagenta: "#c678dd",
        brightCyan: "#56b6c2",
        brightWhite: "#ffffff"
      },
      allowProposedApi: true,
      scrollback: 1e3,
      convertEol: true
    });
    this.fitAddon = new import_xterm_addon_fit.FitAddon();
    this.terminal.loadAddon(this.fitAddon);
    this.terminal.loadAddon(new import_xterm_addon_web_links.WebLinksAddon());
    this.terminal.open(terminalDiv);
    this.fitAddon.fit();
    this.resizeObserver = new ResizeObserver(() => {
      if (this.fitAddon) {
        this.fitAddon.fit();
        if (this.ptyProcess) {
          this.ptyProcess.resize(this.terminal.cols, this.terminal.rows);
        }
      }
    });
    this.resizeObserver.observe(terminalDiv);
    this.loadXtermStyles();
    await this.spawnClaudeProcess();
  }
  async spawnClaudeProcess() {
    try {
      console.log("[Martha] Spawning Claude CLI process...");
      console.log("[Martha] Vault path:", this.vaultPath);
      const claudePath = await this.findClaudeExecutable();
      if (!claudePath) {
        this.terminal.writeln("\x1B[1;31mError: Claude CLI not found.\x1B[0m");
        this.terminal.writeln("Please install Claude Code: npm install -g @anthropic-ai/claude-code");
        this.terminal.writeln('Or ensure "claude" is in your PATH.');
        return;
      }
      console.log("[Martha] Using Claude executable:", claudePath);
      const shell = os.platform() === "win32" ? "cmd.exe" : process.env.SHELL || "/bin/bash";
      const isWindows = os.platform() === "win32";
      this.ptyProcess = pty.spawn(shell, [], {
        name: "xterm-256color",
        cols: this.terminal.cols,
        rows: this.terminal.rows,
        cwd: this.vaultPath,
        env: {
          ...process.env,
          TERM: "xterm-256color",
          COLORTERM: "truecolor"
        }
      });
      console.log("[Martha] PTY process spawned with PID:", this.ptyProcess.pid);
      this.ptyProcess.onData((data) => {
        this.terminal.write(data);
      });
      this.ptyProcess.onExit(({ exitCode, signal }) => {
        console.log("[Martha] PTY process exited:", { exitCode, signal });
        this.terminal.writeln("");
        this.terminal.writeln("\x1B[1;33mClaude CLI session ended.\x1B[0m");
        this.ptyProcess = null;
      });
      this.terminal.onData((data) => {
        if (this.ptyProcess) {
          this.ptyProcess.write(data);
        }
      });
      await new Promise((resolve) => setTimeout(resolve, 500));
      console.log("[Martha] Starting Claude CLI...");
      if (isWindows) {
        this.ptyProcess.write("claude\r");
      } else {
        this.ptyProcess.write("claude\n");
      }
      new import_obsidian2.Notice("\u2713 Claude CLI started in vault directory");
    } catch (error) {
      console.error("[Martha] Failed to spawn Claude process:", error);
      this.terminal.writeln("\x1B[1;31mError starting Claude CLI:\x1B[0m");
      this.terminal.writeln(error.message);
      this.terminal.writeln("");
      this.terminal.writeln("Troubleshooting:");
      this.terminal.writeln("1. Install Claude Code: npm install -g @anthropic-ai/claude-code");
      this.terminal.writeln("2. Run: claude setup-token");
      this.terminal.writeln("3. Ensure Node.js is installed");
      new import_obsidian2.Notice("\u26A0\uFE0F Failed to start Claude CLI - see terminal for details");
    }
  }
  async findClaudeExecutable() {
    const isWindows = os.platform() === "win32";
    const possiblePaths = isWindows ? [
      path.join(process.env.APPDATA || "", "npm", "claude.cmd"),
      path.join(process.env.USERPROFILE || "", "AppData", "Roaming", "npm", "claude.cmd"),
      "claude.cmd",
      "claude"
    ] : [
      "/usr/local/bin/claude",
      path.join(process.env.HOME || "", ".npm-global", "bin", "claude"),
      path.join(process.env.HOME || "", ".local", "bin", "claude"),
      "claude"
    ];
    for (const cmdPath of possiblePaths) {
      try {
        const { execSync } = require("child_process");
        const testCmd = isWindows ? `where ${cmdPath} 2>nul` : `which ${cmdPath} 2>/dev/null`;
        const result = execSync(testCmd, { encoding: "utf8" }).trim();
        if (result) {
          return cmdPath;
        }
      } catch (e) {
        continue;
      }
    }
    return "claude";
  }
  sendToTerminal(text) {
    if (this.ptyProcess) {
      const isWindows = os.platform() === "win32";
      this.ptyProcess.write(text + (isWindows ? "\r" : "\n"));
    }
  }
  loadXtermStyles() {
    if (document.getElementById("martha-xterm-styles")) {
      return;
    }
    const style = document.createElement("style");
    style.id = "martha-xterm-styles";
    style.textContent = `
      /* xterm.js base styles */
      @import url('https://unpkg.com/xterm@5.3.0/css/xterm.css');

      .martha-terminal-container {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
        background: var(--background-primary);
        padding: 0;
      }

      .xterm-container {
        flex: 1;
        width: 100%;
        height: 100%;
        padding: 12px;
        overflow: hidden;
      }

      .xterm {
        height: 100%;
        width: 100%;
      }

      .xterm .xterm-viewport {
        background-color: transparent !important;
      }

      .xterm .xterm-screen {
        background-color: transparent !important;
      }

      /* Scrollbar styling */
      .xterm .xterm-viewport::-webkit-scrollbar {
        width: 10px;
      }

      .xterm .xterm-viewport::-webkit-scrollbar-track {
        background: var(--background-secondary);
      }

      .xterm .xterm-viewport::-webkit-scrollbar-thumb {
        background: var(--background-modifier-border);
        border-radius: 5px;
      }

      .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover {
        background: var(--text-muted);
      }

      /* Selection color */
      .xterm .xterm-selection div {
        background-color: var(--text-selection) !important;
      }

      /* Link styling */
      .xterm a {
        color: var(--text-accent);
        text-decoration: underline;
      }

      .xterm a:hover {
        color: var(--text-accent-hover);
      }
    `;
    document.head.appendChild(style);
  }
  async onClose() {
    console.log("[Martha] Closing terminal view...");
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.ptyProcess) {
      try {
        this.ptyProcess.kill();
      } catch (e) {
        console.error("[Martha] Error killing PTY process:", e);
      }
      this.ptyProcess = null;
    }
    if (this.terminal) {
      this.terminal.dispose();
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  terminalPosition: "right",
  fontSize: 14,
  autoStartClaude: true
};
var MarthaAgentPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Martha Agent plugin");
    await this.loadSettings();
    this.registerView(
      TERMINAL_VIEW_TYPE,
      (leaf) => new TerminalView(leaf, this)
    );
    this.addRibbonIcon("terminal", "Open Claude Terminal", () => {
      this.activateTerminal();
    });
    this.addCommand({
      id: "open-terminal",
      name: "Open Claude Terminal",
      callback: () => this.activateTerminal()
    });
    this.addCommand({
      id: "send-file-to-claude",
      name: "Send current file to Claude",
      callback: () => this.sendCurrentFileToClaude()
    });
    this.addCommand({
      id: "send-selection-to-claude",
      name: "Ask Claude about selection",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.sendTextToClaude(`Explain this:

${selection}`);
        } else {
          new import_obsidian3.Notice("No text selected");
        }
      }
    });
    this.addSettingTab(new MarthaSettingTab(this.app, this));
    console.log("Martha Agent plugin loaded successfully");
  }
  async sendCurrentFileToClaude() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice("No active file");
      return;
    }
    await this.activateTerminal();
    this.sendTextToClaude(`Read and summarize ${activeFile.path}`);
  }
  async sendTextToClaude(text) {
    const leaves = this.app.workspace.getLeavesOfType(TERMINAL_VIEW_TYPE);
    if (leaves.length === 0) {
      await this.activateTerminal();
      setTimeout(() => {
        const newLeaves = this.app.workspace.getLeavesOfType(TERMINAL_VIEW_TYPE);
        if (newLeaves.length > 0) {
          const view = newLeaves[0].view;
          view.sendToTerminal(text);
        }
      }, 1e3);
    } else {
      const view = leaves[0].view;
      view.sendToTerminal(text);
    }
  }
  async activateTerminal() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(TERMINAL_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      if (this.settings.terminalPosition === "right") {
        leaf = workspace.getRightLeaf(false);
      } else {
        leaf = workspace.getLeaf("split", "horizontal");
      }
      if (leaf) {
        await leaf.setViewState({ type: TERMINAL_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("Unloading Martha Agent plugin");
  }
};
